= Тестбенч и CI

Итак, мы xref:simple_adder_one_bit.adoc[написали] простой сумматор и посмотрели, что он выводит что-то адекватное. Такой способ тестирования, конечно, никуда не годится. В более привычных языках программирования принято писать unit-тесты, тестбенч{empty}footnote:[https://www.chipverify.com/verilog/verilog-testbench] нужен в том числе для этого.

Разберём простейший тестбенч:
[source, verilog]
.testbenches/adder_1_bit_tb.sv
----
include::example$adder_1_bit_tb.sv[]
----
<1> Задаём входные данные в виде векторов, которые будем считывать побитно. Примечателен формат целых чисел: `<количество знаков>'<система счисления><знак1>...<знакN>`, в данном случае у нас 8-ми битные числа.
<2> Задаём ожидаемые результаты.
<3> Задаём цикл, тут всё, как у людей, настоящий си-подобный синтаксис.
<4> Считываем очередной бит входных данных.
<5> Проверяем, что актуальные результаты совпали с ожидаемыми, для этого используем `assert`{empty}footnote:[https://www.doulos.com/knowhow/systemverilog/systemverilog-tutorials/systemverilog-assertions-tutorial/].
<6> Если условие не выполнено, то падаем с ошибкой.

// Без include возможно получится сильно проще makefile, но пока оставлю, вдруг передумаем
// [NOTE]
// ====
// Можно заметить в начале файла строку `++`++include "adder_logic_1_bit.sv"`, это альтернатива тому, чтобы передавать iverilog-у все файлы с необходимыми модулями. Команда `++`++include` вставляет содержимое указанного файла в начало. И тогда просимулировать можно командой:
// [source, console]
// ----
// $ iverilog testbenches/adder_1_bit_tb.sv -g2012 -o build/adder_1_bit_tb
// ----
// Тут, правда, есть нюанс: иногда нужно дополнительно указывать директории, в которых лежат модули с помощью флага `-I`.
// ====

Это больше похоже на привычные нам тесты. И раз они есть, значит можно сделать любимый всеми программистами CI. 