= Комбинационные схемы
:figure-caption: Рисунок
__Какие-то общие слова про них. Не уверен, какие именно.__

Разберёмся же с этой концепцией на примере сумматора.
Нужно сложить два бита с переполнением.
Разберём код, реализующий эту функциональность:
[source, verilog]
.adder_plus_1_bit.sv
----
include::example$adder_plus_1_bit.sv[]
----
<1> Первый входной бит.
<2> Второй входной бит.
<3> Элемент, отвечающий за переполнение на входе.
<4> Элемент, отвечающий за переполнение на выходе.
<5> Результат сложения.
<6> Не забывайте ставить `;`.
<7> Результат сложения может выйти за пределы одного бита, тут можно сконкатенировать два элемента в один через фигурные скобки{empty}footnote:[https://www.chipverify.com/verilog/verilog-concatenation].
Тогда первый совпадёт с битом переполнения, а второй -- с суммой.
Важно отметить использование непрерывного присваивания через `assign`{empty}footnote:[https://www.chipverify.com/verilog/verilog-assign-statement].
Оно "сцепляет" элементы друг с другом, то есть при любом изменении одного элемента, изменится и другой.

Однако странно использовать встроенное сложение в своей реализации сложения.
Опираясь на https://en.wikipedia.org/wiki/Adder_(electronics)#Full_adder[выкладки умных людей], можно избавится от этого недоразумения, и предложить реализацию исключительно на логических операциях:
[source, verilog]
.adder_logic_1_bit.sv
----
include::example$adder_logic_1_bit.sv[]
----
<1> Элемент, отвечающий за переполнение на входе.
<2> Элемент, отвечающий за переполнение на выходе.

[NOTE]
====
Можно воспользоваться конкатенацией, как в прошлом примере, это избавит нас от лишнего `assign`:

[source, verilog]
----
assign {sum, c_out} = {a ^ b ^ c_in, (a & b) | (c_in & (a ^ b))}; 
---- 
Однако, как видно, это несколько ухудшает читаемость кода.
====

Важно не забывать специфику: все модули, написанные на SystemVerilog, должны синтезироваться в принципиальную схему.
Существуют механизмы, позволяющие синтезировать rtl из кода.
Подробнее, как получить её в виде картинки, можно почитать xref:rtl_pics_synthesis.adoc[тут].
Проделав необходимые действия с нашим сумматором, получаем схему:

image::adder_logic_1_bit.svg[title="Синтезированная схема сумматора"]

Для проверки (конечно, просто визуальной) можно написать подобие тестбенча{empty}footnote:[https://www.chipverify.com/systemverilog/systemverilog-simple-testbench](коротко, аналог юнит-тестов), подробнее о котором мы поговорим чуть позже:
[source, verilog]
.adder_logic_1_bit_tb.sv
----
include::example$adder_logic_1_bit_tb.sv[]
----
<1> Объявляем всё, что нам потребуется для работы.
<2> Задаём тестируемое устройство.
<3> Передавать аргументы можно и просто по порядку, но их зачастую больше, чем мы привыкли.
<4> Выполняем блок в начальный момент времени, можно использовать только в тестбенчах.
<5> Задаём задержку, иначе всё выведется раньше, чем успеет посчитаться (можно использовать другое число, но исторически повелось писать 10).

Давайте просимулируем полученный файл.
Тестбенч использует другой модуль, так что iverilog-у необходимо передать и его тоже:
[, console]
----
$ iverilog -s adder_logic_1_bit_tb adder_logic_1_bit.sv adder_logic_1_bit_tb.sv -g2012 -o build/adder_logic_1_bit_tb
----
После запустим его:
[, console]
----
$ build/adder_logic_1_bit_tb
----
Вывод должен выглядеть так:
[, console]
----
0 (из переполнения) + 0 + 1 = 1 (0 в переполнении)
0 (из переполнения) + 1 + 1 = 0 (1 в переполнении)
1 (из переполнения) + 0 + 0 = 1 (0 в переполнении)
----
