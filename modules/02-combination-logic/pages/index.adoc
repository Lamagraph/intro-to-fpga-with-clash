= 2. Комбинационные схемы
__Какие-то общие слова про них. Не уверен, какие именно.__

В этом разделе познакомимся с комбинационными схемами, тестбенчами{empty}footnote:[https://www.chipverify.com/systemverilog/systemverilog-simple-testbench] (коротко, аналог юнит-тестов), напишем простейший сумматор, на примере которого покажем всё вышеперечисленное.

IMPORTANT: Обязательно ознакомьтесь с xref:01-basic-environment:index.adoc[настройкой окружения], в дальнейшем будет предполагаться, что все шаги оттуда были выполнены.

Разберёмся же с концепцией комбинационных схем на примере сумматора.
Нужно сложить два бита с переполнением (оно же -- перенос разряда).
Разберём код, реализующий эту функциональность:
[source, verilog]
.src/02-combination-logic/adder_plus_1_bit.sv
----
include::example$adder_plus_1_bit.sv[]
----
<1> Первый входной бит.
<2> Второй входной бит.
<3> Бит, отвечающий за переполнение на входе.
<4> Бит, отвечающий за переполнение на выходе.
<5> Результат сложения.
<6> Не забывайте ставить `;`.
<7> Сложение работает как привычное сложение двоичных чисел.
Соответственно, сначала будет одни бит переполнения, а потом -- результирующий бит.
Отловить это можно с помощью оператора конкатенации{empty}footnote:[https://www.chipverify.com/verilog/verilog-concatenation] через фигурные скобки.
Тогда мы явно свяжем шину, состоящую из двух битов (`c_out` и `sum`) с результатом сложения.
Также важно отметить использование непрерывного присваивания через `assign`{empty}footnote:[https://www.chipverify.com/verilog/verilog-assign-statement].
Оно "сцепляет" элементы друг с другом, то есть при любом изменении одного элемента, изменится и другой.

NOTE: Непрерывное присваивание -- это единственный способ "положить" что-то в результирующие переменные.
То есть выражения для них могут быть очень сложными, со сложной логикой, но всё сведётся к `assign output_var = expr`. 

Однако странно использовать встроенное сложение в своей реализации сложения.
Опираясь на https://en.wikipedia.org/wiki/Adder_(electronics)#Full_adder[выкладки умных людей], можно избавится от этого недоразумения и предложить реализацию исключительно на логических операциях:
[source, verilog]
.src/02-combination-logic/adder_logic_1_bit.sv
----
include::example$adder_logic_1_bit.sv[]
----

[NOTE]
====
Можно воспользоваться конкатенацией, как в прошлом примере, это избавит нас от лишнего `assign`:

[source, verilog]
----
assign {sum, c_out} = {a ^ b ^ c_in, (a & b) | (c_in & (a ^ b))}; 
---- 
Однако, как видно, это несколько ухудшает читаемость кода.
====

Важно не забывать специфику: все модули (если в них не используются некоторые специальные конструкции), написанные на SystemVerilog, должны синтезироваться в принципиальную схему.
Существуют механизмы, позволяющие сделать это.
Подробнее, как получить схему в виде картинки, можно почитать xref:rtl_pics_synthesis.adoc[тут].
Проделав необходимые действия с нашим сумматором, получаем схему:

image::adder_logic_1_bit.svg[title="Синтезированная схема сумматора"]

Конечно, после того, как мы написали что-то простое, хочется вывести результат и посмотреть, адекватно ли всё работает. Давайте сделаем это:
[source, verilog] 
.src/02-combination-logic/adder_logic_1_bit_tb.sv
----
include::example$adder_logic_1_bit_tb.sv[]
----
<1> Объявляем всё, что нам потребуется для работы.
<2> Задаём тестируемый модуль{empty}footnote:[https://www.chipverify.com/verilog/verilog-module-instantiations].
Тут почти то же самое, что и вызов функции, но результат записывается в выделенные переменные и изменяется непрерывно с изменением входных данных.
<3> Передавать аргументы можно и просто по порядку, но их зачастую больше, чем мы привыкли, легко запутаться.
<4> Выполняем блок в начальный момент времени{empty}footnote:[https://www.chipverify.com/verilog/verilog-initial-block].
Этот блок ломает синтезируемость модуля, так что обычно его используют только в тестбенчах.
<5> В SystemVerilog всё довольно сложно с последоватальностью выполнения команд, здесь серьёзное отличие с привычными нам языками, потому что тут мы можем управлять ходом выполнения программы потактово.
Так что, чтобы быть уверенным в том, в какой момент исполнятся команды, нужно задавать задержку{empty}footnote:[https://www.chipverify.com/verilog/verilog-delay-control] (либо делать что-то хитрее, о чём мы поговорим позже).
Именно это мы и сделали.
У нас задержка в 10 наносекунд (это изменяемый параметр, называемый `time_unit`{empty}footnote:[https://www.chipverify.com/verilog/verilog-timescale]), можно взять и другую, но исторически повелось брать именно 10.

Давайте просимулируем полученный файл.
Этот модуль использует другой, так что iverilog-у необходимо передать и его тоже:
[, console]
----
$ iverilog -s adder_logic_1_bit_tb adder_logic_1_bit.sv adder_logic_1_bit_tb.sv -g2012 -o build/adder_logic_1_bit_tb
----
[NOTE]
====
Флаг `-s` позволяет явно указать верхний модуль, в нашем случае это `adder_logic_1_bit_tb`. Конкретно здесь можно обойтись и без него, но если проект достаточно сложный, то лучше явно прописывать. Подробнее о том, какие есть флаги и что они позволяют сделать, можно почитать https://steveicarus.github.io/iverilog/usage/command_line_flags.html[здесь].
====

После запустим его:
[, console]
----
$ build/adder_logic_1_bit_tb
----
Вывод должен выглядеть так:
[, console]
----
0 (из переполнения) + 0 + 1 = 1 (0 в переполнении)
0 (из переполнения) + 1 + 1 = 0 (1 в переполнении)
1 (из переполнения) + 0 + 0 = 1 (0 в переполнении)
----

В xref:testbench_ci.adoc[следующем разделе] мы подробнее поговорим про тестбенчи и настроим CI.