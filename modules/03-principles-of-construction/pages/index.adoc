= 3. Многобитный сумматор

[source, verilog]
./src/03-principles-of-constructor/adder_multibits_reuse.sv
----
include::example$adder_multibits_reuse.sv[]
----
<1> Модули можно параметризовать{empty}footnote:[https://www.chipverify.com/verilog/verilog-parameters], а потом использовать параметр в любом месте модуля. Потом при инстанциации модуля можно поставить то значение, которое хочется.
<2> Параметры можно использовать даже описании входных и выходных данных. Очень мощный механизм, который обычно отсутствует в других языках.
<3> Задаём шину промежуточных битов переполнения.
<4> Начальный бит переполнения нужно учесть в промежуточной шине.
<5> Переменная, нужная только для генерации.
<6> Сейчас нужно много раз вызывать модуль `adder_logic_1_bit`, в SystemVerilog для решения этой проблемы можно генерировать код{empty}footnote:[https://www.chipverify.com/verilog/verilog-generate-block].
<7> Для каждого бита используем модуль однобитного сложения.
<8> Ну, и, что вполне логично, запоминаем бит переполнения для использования на следующем шаге (в школе это говорилось "а один держим в уме").

Интересно посмотреть, во что синтезируется этот модуль.

image::adder_multibits_reuse.svg[title="Синтезированная схема многобитного сумматора"]

Тут видно, что блок модуля однобитного сложения используется четыре раза.
Что ожидаемо: он был вызван для каждого бита четырёхбитной шины.
Это напоминает нам о том, что, хоть они и похожи, но инстациация модуля в SystemVerilog и вызов функции в привычных языках -- разные вещи.

[NOTE]
====
Можно добавить флаг `--flatten` в `prep` в xref:02-combination-logic:rtl_pics_synthesis.adoc[гайдике]. Он отвечает за то, будут ли при синтезе раскрываться используемые модули. Если это сделать, то синтезируется такая схема.

image::adder_multibits_reuse_flatten.svg[title="Развёрнутая схема многобитного сумматора"]
====

Ну, не стоит забывать, что всё это делается в учебных целях, и сложение битветоров реализовано, конечно, из коробки.

[source, verilog]
./src/03-principles-of-constructor/adder_multibits_bitvectors.sv
----
include::example$adder_multibits_bitvectors.sv[]
----

Схема для этого модуля будет выглядеть довольно просто.

image::adder_multibits_bitvectors_flatten.svg[title=" Схема многобитного сумматора на битвекторах"]

Человеку привычно воспринимать числа в десятичной записи, и в нормальных языках для такого есть отдельный тип `integer`.
В этом смысле SystemVerilog тоже нормальный{empty}footnote:[https://www.chipverify.com/systemverilog/systemverilog-data-types-integer-byte].
Так что наш модуль в некотором смысле вырождается.

[source, verilog]
./src/03-principles-of-constructor/adder_multibits_int.sv
----
include::example$adder_multibits_int.sv[]
----

image::adder_multibits_int_flatten.svg[title=" Схема многобитного сумматора с использованием int"]
