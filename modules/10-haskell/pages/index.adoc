= 10. Haskell. Разминка

Полноценное изучение Haskell достойно отдельного курса (и даже не одного).
Потому мы настоятельно рекомендуем изучать хотя бы xref:ROOT:index.adoc#_рекомендуемые_для_изучения_материалы[рекомендованные материалы], а лучше даже выйти за границы предложенного списка.

Ниже будет лишь база, позволяющая нам начать пользоваться Clash как инструментом.

Шаги, которые мы проделаем.

. xref:install-haskell.adoc[Установим Haskell] (компилятор, рантайм, интеграция с IDE, все дела).
. Создадим базовый проект с использованием https://docs.haskellstack.org/en/stable/[stack].
.. Мы не будем дискутировать на тему https://docs.haskellstack.org/en/stable/[stack] vs https://www.haskell.org/cabal/[cabal]. Clash по умолчанию использует stack, так что и мы начнём с него.
. Напишем ряд простых функций, чтобы познакомиться с основами языка.

== Полезные инструменты

Прежде чем бросаться писать код, полезно знать про пару ресурсов, которые могут упростить это занятие.

. https://hoogle.haskell.org/[Hoogle] -- Haskell-специфичный поисковик. Поможет найти материалы про различные странные символы, используемые в языке (с чем обычный поисковик справится с трудом), узнать, что сообщество уже сочинило функцию, которая делает то, что нужно (в том числе просто по её типу) и т.д.
. https://hackage.haskell.org/[Hackage] -- репозиторий пакетов. Если нужна какая-то функция или целый инструмент, скорее всего он есть тут, либо его ещё не придумали.

== Основы

После того, как xref:install-haskell.adoc[всё необходимое установлено], создадим проект по https://docs.haskellstack.org/en/stable/tutorial/hello_world_example/[дефолтному шаблону.]

TIP: Чтобы немного упростить себе жизнь, можно использовать команду `stack run`. Она и пересоберёт, и запустит.

Первый делом найдите Lib.hs и поменяйте выводимую строку.
Перезапустите проект. Вывод поменялся? Если да, то всё отлично. Попробуем пописать новые функции.

[, haskell]
.src/10-haskell/demoproject/src/Lib.hs
----
include::example$Lib.hs[]
----
<1> Первым делом поменяли выводимую строку, чтобы убедиться, что всё работает и нас не обманули.
<2> Указываем, какие функции будут экспортироваться из модуля.
<3> Во многих случаях компилятор может сам вывеси типы, но для верхнеуровневых функций их лучше указывать. Попробуйте удалить типы и пересобрать проект -- должны получить предупреждение.
В данном случае функция просто совершает какой-то ввод-вывод.
Для этого приходится использовать https://mmhaskell.com/monads[монады]. В данном случае, https://www.haskell.org/tutorial/io.html[IO].
Научиться пользоваться данным механизмом крайне желательно для понимания дальнейшего материала.
<4> Наша функция может принять два элемента типа, который ведёт себя как число, и вернёт пару элементов того де типа.
Для более детального понимания того, что здесь происходит рекомендуется почитать про https://www.haskell.org/tutorial/classes.html[type classes] и, в частности, про https://hackage.haskell.org/package/base-4.20.0.1/docs/GHC-Num.html[class Num].
<5> Тут мы вручную указали более узкий тип, чем может вывести компилятор. Это не страшно, если нас устраивает. Попробуйте убрать аннотацию и посмотреть, какой тип выведет компилятор.
<6> Все объявления рекурсивны (не надо использовать отдельные ключевые слова для обозначения рекурсивных определений). С этим надо быть аккуратным, так как иногда при рефакторинге появляются неприятные эффекты.
<7> Сопоставление с образцом для аргументов верхнеуровневых функций. Варианты просматриваются сверху вниз.

Для быстрого знакомства с базовым синтаксисом можно использовать https://mmhaskell.com/liftoff/syntax[вот эту статью.]

Далее, нам важно научиться писать тесты.
Для этого предлагается использовать библиотеку https://hackage.haskell.org/package/hedgehog[Hedgehog].

Попробуем создать простые тесты на написанные нами функции.

Для начала добавим соответствующий пакет к нам в проект.
Для этого нужно добавить пакет в `package.yaml`, в раздел с зависимостями тестового подпроекта.

[, yaml]
.src/10-haskell/demoproject/package.yaml
----
include::example$package.yaml[]
----
<1> Зависимость нужна только для тестов.
<2> Добавляем имя пакета. Пока не заморачиваемся с версиями, просто берём актуальны.

[, haskell]
.src/10-haskell/demoproject/test/Spec.hs
----
include::example$Spec.hs[]
----
<1> Подключим расширение https://markkarpov.com/tutorial/th.html[Template Haskell], дающее возможности метапрограммирования времени компиляции.
С данным расширением рекомендуется познакомиться поближе, так как оно достаточно активно используется в Clash.
<2> Загрузим пакеты, нужные для реализации тестов.
<3> Загрузим тестируемую библиотеку.
<4> Опишем свойство.
+
IMPORTANT: Префикс `prop_` важен! По нему определяется, какие функции надо превратить в тесты.
<5> Сгенерируем некоторое количество чисел от 0 до 30.
<6> Проверим, что Фибоначчи "всегда" положителен.
<7> Точка входа. Обязательно `main` в нашем шаблоне.
<8> Магическое заклинание, которое найдёт все функции, на основе которых надо сделать тесты.

Теперь в корне нашего проекта можно запустить:

[, cmd]
----
stack test
----

Если всё сделано правильно, то получим что-то такое:

[, cmd]
----
Progress 1/2: demoproject━━━ Main ━━━
  ✓ prop_fibIsPositive passed 100 tests.
  ✓ prop_fibIsFib passed 100 tests.
  ✓ prop_fibIsMonotonic passed 100 tests.
  ✓ 3 succeeded.
----

Попробуйте задать какое-то неправильное свойство, проверьте, что тесты не пройдут.

IMPORTANT: Тесты, основанные на свойствах не заменяют классические тесты. Например, необходимо проверять различного рода специфичные входы.

TIP: Для Haskell существует библиотека-хаб https://hackage.haskell.org/package/tasty[tasty], которая включает множество различных подходов к тестированию. В том числе, включает в себя hedgehog.

IMPORTANT: Обязательно порешайте xref:exercises.adoc[упражнения].
