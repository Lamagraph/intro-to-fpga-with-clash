= 10. Haskell. Разминка

Полноценное изучение Haskell достойно отдельного курса (и даже не одного).
Потому мы настоятельно рекомендуем изучать хотя бы xref:ROOT:index.adoc#_рекомендуемые_для_изучения_материалы[рекомендованные материалы], а лучше даже выйти за границы предложенного списка.

Ниже будет лишь база, позволяющая нам начать пользоваться Clash как инструментом.

Шаги, которые мы проделаем.

. xref:install-haskell.adoc[Установим Haskell] (компилятор, рантайм, интеграция с IDE, все дела).
. Создадим базовый проект с использованием https://docs.haskellstack.org/en/stable/[stack].
.. Мы не будем дискутировать на тему https://docs.haskellstack.org/en/stable/[stack] vs https://www.haskell.org/cabal/[cabal]. Clash по умолчанию использует stack, так что и мы начнём с него.
. Напишем ряд простых функций, чтобы познакомиться с основами языка.

== Полезные инструменты

Прежде чем бросаться писать код, полезно знать про пару ресурсов, которые могут упростить это занятие.

. https://hoogle.haskell.org/[Hoogle] -- Haskell-специфичный поисковик. Поможет найти материалы про различные странные символы, используемые в языке (с чем обычный поисковик справится с трудом), узнать, что сообщество уже сочинило функцию, которая делает то, что нужно (в том числе просто по её типу) и т.д.
. https://hackage.haskell.org/[Hackage] -- репозиторий пакетов. Если нужна какая-то функция или целый инструмент, скорее всего он есть тут, либо его ещё не придумали.

== Основы

После того, как xref:install-haskell.adoc[всё необходимое установлено], создадим проект по https://docs.haskellstack.org/en/stable/tutorial/hello_world_example/[дефолтному шаблону.]

TIP: Чтобы немного упростить себе жизнь, можно использовать команду `stack run`. Она и пересоберёт, и запустит.

Первый делом найдите Lib.hs и поменяйте выводимую строку.
Перезапустите проект. Вывод поменялся? Если да, то всё отлично. Попробуем пописать новые функции.

[, haskell]
.src/10-haskell/demoproject/src/Lib.hs
----
include::example$Lib.hs[]
----
<1> Указываем, какие функции будут экспортироваться из модуля.
<2> Во многих случаях компилятор может сам вывеси типы, но для верхнеуровневых функций их лучше указывать. Попробуйте удалить типы и пересобрать проект -- должны получить предупреждение.
В данном случае функция просто совершает какой-то ввод-вывод.
<3> Первым делом поменяли выводимую строку, чтобы убедиться, что всё работает и нас не обманули.
Для этого приходится использовать https://mmhaskell.com/monads[монады]. В данном случае, https://www.haskell.org/tutorial/io.html[IO].
Научиться пользоваться данным механизмом крайне желательно для понимания дальнейшего материала.
<4> Наша функция может принять два элемента типа, который ведёт себя как число, и вернёт пару элементов того же типа.
Для более детального понимания того, что здесь происходит рекомендуется почитать про https://www.haskell.org/tutorial/classes.html[type classes] и, в частности, про https://hackage.haskell.org/package/base-4.20.0.1/docs/GHC-Num.html[class Num].
<5> Тут мы вручную указали более узкий тип, чем может вывести компилятор. Это не страшно, если нас устраивает. Попробуйте убрать аннотацию и посмотреть, какой тип выведет компилятор.
<6> Сопоставление с образцом для аргументов верхнеуровневых функций. Варианты просматриваются сверху вниз.
<7> Все объявления рекурсивны (не надо использовать отдельные ключевые слова для обозначения рекурсивных определений). С этим надо быть аккуратным, так как иногда при рефакторинге появляются неприятные эффекты.

Для быстрого знакомства с базовым синтаксисом можно использовать https://mmhaskell.com/liftoff/syntax[вот эту статью.]
Также рекомендуется познакомиться со https://hackage.haskell.org/package/base-4.20.0.1/docs/Prelude.html[стандартной библиотекой] и на всякий случай почитать https://typeclasses.com/ghc/no-implicit-prelude[как и зачем её заменять], потому что Clash как раз предоставляет свою стандартную библиотеку.

IMPORTANT: Форматирование в Haskell важно. Идея та же, что и в Python, YAML или F#, но местами более сурово и изощрённо.

== Тесты, основанные на свойствах

Далее, нам важно научиться писать тесты.
Для этого предлагается использовать библиотеку https://hackage.haskell.org/package/hedgehog[Hedgehog].

Попробуем создать простые тесты на написанные нами функции.

Для начала добавим соответствующий пакет к нам в проект.
Для этого нужно добавить пакет в `package.yaml`, в раздел с зависимостями тестового подпроекта.

[, yaml]
.src/10-haskell/demoproject/package.yaml
----
include::example$package.yaml[]
----
<1> Зависимость нужна только для тестов.
<2> Добавляем имя пакета. Пока не задумываемся над версиями, просто берём актуальный.

[, haskell]
.src/10-haskell/demoproject/test/Spec.hs
----
include::example$Spec.hs[]
----
<1> Подключим расширение https://markkarpov.com/tutorial/th.html[Template Haskell], дающее возможности метапрограммирования времени компиляции.
С данным расширением рекомендуется познакомиться поближе, так как оно достаточно активно используется в Clash.
Также можно почитать про то, что такое https://typeclasses.com/extensions-intro[механизм расширений в Haskell] и полистать https://typeclasses.com/ghc/extensions[список этих самых расширений].
Многие из перечисленных используются в Clash и нам ещё встретятся.
<2> Загрузим пакеты, нужные для реализации тестов.
<3> Загрузим тестируемую библиотеку.
<4> Опишем свойство -- некоторое условие, которому должна удовлетворять тестируемая функция с учётом используемых ограничений на входные данные.
+
TIP: Одно из замечательных свойств, которым часто пользуются при таком подходе -- тестируемая функция должна вести себя так же, как некоторая другая.
Часто даже для функций со сложным внутренним устройством пишут эталоны, которые ведут себя так же, но устроены существенно проще.
Например, две сортировки, независимо от алгоритма, вести себя должны одинаково.
+
IMPORTANT: https://hackage.haskell.org/package/hedgehog-1.5/docs/Hedgehog.html#v:discover[Префикс `prop_` важен!] По нему определяется, какие функции надо превратить в тесты.
<5> Сгенерируем некоторое количество чисел от 0 до 30.
<6> Проверим, что Фибоначчи "всегда" положителен.
<7> Для некоторых случаев https://hackage.haskell.org/package/hedgehog-1.5/docs/Hedgehog.html#v:-61--61--61-[определены] отдельные операторы, такие как `===`. Данная строка эквивалентна
+
[, haskell]
----
assert $ fib x == fib (x - 2) + fib (x - 1)
----
<8> Точка входа. Обязательно `main` в нашем шаблоне.
<9> Магическое заклинание, которое найдёт все функции, на основе которых надо сделать тесты.
    Как раз оно и использует Template Haskell.

Теперь в корне нашего проекта можно запустить:

[, cmd]
----
stack test
----

Если всё сделано правильно, то получим что-то такое:

[, cmd]
----
Progress 1/2: demoproject━━━ Main ━━━
  ✓ prop_fibIsPositive passed 100 tests.
  ✓ prop_fibIsFib passed 100 tests.
  ✓ prop_fibIsMonotonic passed 100 tests.
  ✓ 3 succeeded.
----

Попробуйте задать какое-то неправильное свойство, проверьте, что тесты не пройдут.

IMPORTANT: Тесты, основанные на свойствах не заменяют классические тесты. Например, необходимо проверять различного рода специфичные входы (крайние случаи).

TIP: Для Haskell существует библиотека-хаб https://hackage.haskell.org/package/tasty[tasty], которая включает множество различных подходов к тестированию. В том числе, включает в себя hedgehog.

IMPORTANT: Обязательно порешайте xref:exercises.adoc[упражнения].
