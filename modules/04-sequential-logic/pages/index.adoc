# 4. Последовательностная логика

До сих пор мы рассматривали только комбинационные схемы.
В них выходные сигналы непрерывно зависят от входных, однако возможность сохранять состояние отсутствует.
На помощь нам приходит последовательностная (секвенциальная) логика.

Пока что сигналы в наших схемах изменялись "мгновенно", но логика подсказывает, что так ничего запомнить не получится, поэтому нам нужен некий управляющий сигнал.
Главное требование к управляющему сигналу (чаще называемому clock или `clk`) -- циклическое изменение уровня сигнала с заданным периодом.

Для сохранения же нам нужна какая-то ячейка памяти.
Такой ячейкой обычно является регистр -- элемент, который по заданному условию сохраняет значение приходящего в него сигнала.
Условием срабатывания триггера чаще всего является восходящий фронт волны управляющего сигнала.

Ещё стоит сказать про сигнал сброса, обычно называемый `rst`.
Он служит для сброса состояния секвенциальной схемы.

После знакомства с новыми терминами возьмёмся за пример.
В xref:03-principles-of-construction:exercises.adoc[упражнениях к предыдущей главе] предлагалось написать свёртку.
Тогда можно было написать свёртку только при условии, что все элементы поступают одновременно.
Если же мы хотим "сворачивать" элементы последовательно, то нам необходимо сохранять предыдущее состояние.
Тут нас и спасут регистры.

Рассмотрим код модуля, который последовательно суммирует числа.
[,verilog]
.src/04-sequential-logic/sum_reduce/sum_reduce.sv
----
include::example$sum_reduce.sv[]
----
<1> Подключаем управляющий сигнал
<2> и сигнал сброса.
<3> "Переменная" для сохранения накопленной суммы.
<4> `always_comb` позволяет описывать комбинационную логику.
В данном случае код эквивалентен коду: `assign sum = acc + num;`.
В общем же случае `always_comb` блоки позволяют описывать более сложную комбинационную логику, например с ветвлениями{empty}footnote:[https://www.verilogpro.com/systemverilog-always_comb-always_ff/].
<5> Складывает накопленную сумму с новым числом.
<6> `always_ff` описывает последовтательностную логику.
`ff` указывает на то, что мы хотим использовать именно регистр (flip-flop){empty}footnote:[О том, какие ещё `always` блоки бывают, можно почитать здесь: https://stackoverflow.com/questions/23101717/difference-among-always-ff-always-comb-always-latch-and-always].
`@(posedge clk)` означает, что блок будет исполняться при каждом переднем фронте (posedge) сигнала `clk`.
<7> Проверяем наличие сигнала сброса.
<8> В случае наличия сигнала сброса, обнуляем наш аккумулятор.
<9> В ином случае запоминаем накопленную сумму.

Можно нарисовать схему и показать, что вот реально регистр появился.

Тут думаю надо что-то типа тестбенча.
Точнее может быть даже то, что есть сейчас.
Просто на понаблюдать.
[,verilog]
.src/04-sequential-logic/sum_reduce/sum_reduce.sv
----
include::example$sum_reduce_tb.sv[]
----

Дальше показать GTKWave.
Тут правда будет неприятно потому что там чуть ли не на скринах надо показывать как им пользоваться.
Но в итоге будет прям понятно что и как выглядит :).

Реальный тестбенч я примерно представляю как написать, но там реально будет жесть с точки зрения того, что придётся вывалить кучу конструкций из SV и, видимо, массивы.

Дальше хорошо бы показать, что вот есть cocotb и он сильно приятнее (должен быть).
