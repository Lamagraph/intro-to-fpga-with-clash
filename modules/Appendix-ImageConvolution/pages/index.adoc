= Свёртка изображений

Другие названия: image filtering, image convolution. Да-да, ровно то, что применяется в свёрточных нейронных сетях.

Считаем, что работаем с чёрно-белым изображением.
То есть оно может быть представлено как двумерная матрица байт (прозрачности нет, метаданных нет).

Ядро свёртки -- квадратная матрица нечётного, как правило небольшого, размера.


Пусть есть изображение stem:[A] произвольного размера и ядро свёртки stem:[B] размера stem:[m \times m].
Пусть stem:[p = \lfloor m / 2 \rfloor].

Тогда свёртка изображения stem:[A] ядром stem:[B] -- это изображение (также матрица) stem:[C], такая что.

[stem]
++++
    C[i,j] = \sum_{k=-p}^{p} \sum_{l=-p}^{p} A[i-k,j-l]B[p+k,p+l]
++++

IMPORTANT: Обратите внимание на то, что формула выше не учитывает обработку пикселей на краю изображения, которая может быть организована разными способами.

IMPORTANT: Обратите внимание на то, фильтр можно представить как матрицу (часто чисел с плавающей точкой), а можно и как целочисленную матрицу и коэффициент перед ней.

Если пиксель на краю, то возможно несколько вариантов.

 * Использовать дефолтное значение
 * Копировать край
 * Применять свёртку так, чтобы не было выхода за границу. Тогда размер выходного изображения будет меньше входного.

В нейронных сетях веса в матрице stem:[B] как раз таки "обучаются".
Но существуют предопределённые ядра, выполняющие вполне конкретные операции: размытие, выделение границ.
Больше примеров:

 * https://sbme-tutorials.github.io/2018/cv/notes/4_week4.html[Image Filtering and Edge Detection]
 * https://lodev.org/cgtutor/filtering.html[Image Filtering]


IMPORTANT: Обязательно порешайте xref:exercises.adoc[упражнения].
