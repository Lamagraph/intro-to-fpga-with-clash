= 7. Автоматы

В общем виде автомат можно понимать как систему, которая может находиться в каком-то из заранее известного множества состояний, переходить из одного состояния в другое под определённым внешним воздействием.


== Конечный автомат

Конечные автоматы возникают и изучаются в различных областях науки.
Традиционно, в теории формальных языков.
Туда и рекомендуется заглянуть для более фундаментального ознакомления с темой.
В частности, можно обратиться к следующей литературе.

* Классика по теории формальных языков: https://dl.acm.org/doi/book/10.5555/578595[M. A. Harrison. 1978. "Introduction to Formal Language Theory"].
* Свежее по теории автоматов и их применению в различных областях: https://ems.press/books/standalone/172[Editors: Jean-Éric Pin. 2021. "Handbook of Automata Theory"].

Нас же будут интересовать детерминированные конечные автоматы.

====
Детерминированный конечный автомат -- это кортеж
stem:[\langle \Sigma, Q,q_s, Q_f, \delta \rangle],
где

* stem:[\Sigma] -- конечный (входной) алфавит;
* stem:[Q] -- конечное множество состояний;
* stem:[q_s] -- стартовое состояние (stem:[q_s \in Q]);
* stem:[Q_f] -- множество финальных состояний (stem:[Q_f \subseteq Q]);
* stem:[\delta: Q \times \Sigma \to Q] -- функция переходов.

====

NOTE: Если stem:[\delta] всюду определена, то автомат полный. Иногда stem:[\delta] может быть частично определённой функцией.


Можно сказать, что автомат начинает свою работу в начальном состоянии, читает очередной символ с входной ленты, переходит в новое состояние.
Если в процессе работы автомат оказался в конечном состоянии и вод пуст, то работа завершилась успешно.
Во всех остальных случаях работа завершилась с ошибкой.

NOTE: Из финальных состояний могут существовать переходы. Так что автомат не обязан просто остановиться в финальном состоянии, он продолжает работу "пока может".

Автомат удобно представлять в виде графа, где вершины -- это состояния, а рёбра -- переходы.

Ниже представлен автомат со стартовым состоянием 0, финальными состоянием 2 и функцией переходов, которая ведёт себя следующим образом.

* stem:[\delta(0,a) = 1]
* stem:[\delta(1,b) = 1]
* stem:[\delta(1,c) = 2]
* stem:[\delta(2,b) = 0]

.Детерминированный конечный автомат: 0 -- стартовое состояние, 2 -- финальное состояние
image::dfa.dot.svg[Детерминированный конечный автомат]

== Автомат Мили

"Простой" конечный автомат только читает вход.
Иногда хочется, чтобы он что-то выдавал на выходную ленту.
Одна из модификаций, которая умеет такое делать -- автомат Мили.

====
Автомат Мили -- это кортеж
stem:[\langle \Sigma_{in}, \Sigma_{out}, Q,q_s, \delta \rangle],
где

* stem:[\Sigma_{in}] -- конечный входной алфавит;
* stem:[\Sigma_{out}] -- конечный выходной алфавит;
* stem:[Q] -- конечное множество состояний;
* stem:[q_s] -- стартовое состояние (stem:[q_s \in Q]);
* stem:[\delta: Q \times \Sigma_{in} \to Q \times (\Sigma_{out} \cup \{ \varepsilon \})] -- функция переходов.

====

Таким образом, автомат Мили находясь в каком-либо состоянии и видя очередной входной символ переходит в новое состояние и "печатает" на выходную ленту какой-либо символ.
То есть его удобно рассматривать как своего рода переводчик.

NOTE: В нашем определении (как и во многих других) нету финальных состояний. То есть автомат Мили работает до конца входа.

NOTE: Символ stem:[\varepsilon] делает возможными переходы при которых автомат ничего не выдаёт на выход. Иногда это запрещают, требуя, чтобы на каждый переход что-то "печаталось" на выходную ленту.

Данный тип автомата также удобно представлять графически: на ребре появляются две метки, одна из которых -- вход, вторая -- выход.

.Автомат Мили: 0 -- стартовое состояние, {a, b, c, d} -- входной алфавит, {1, 2, 3, 4} -- выходной алфавит
image::mealy.dot.svg[Автомат Мили]

== Автомат Мура

Ещё одна модель, которая позволяет "переводить" вход в выход -- автомат Мура.

====
Автомат Мура -- это кортеж
stem:[\langle \Sigma_{in}, \Sigma_{out}, Q, q_s, \delta, \delta_{out} \rangle],
где

* stem:[\Sigma_{in}] -- конечный входной алфавит;
* stem:[\Sigma_{out}] -- конечный выходной алфавит;
* stem:[Q] -- конечное множество состояний;
* stem:[q_s] -- стартовое состояние (stem:[q_s \in Q]);
* stem:[\delta: Q \times \Sigma_{in} \to Q] -- функция переходов;
* stem:[\delta_{out}: Q \to \Sigma_{out}] -- функция, генерирующая выходное значение.

====

NOTE: В нашем определении (как и во многих других) нету финальных состояний. То есть автомат Мура тоже работает до конца входа.

Данный тип автомата также удобно представлять графически: в состоянии, кроме его метки, изображается выходной символ.

.Автомат Мура: 0 -- стартовое состояние, {a, b, c, d} -- входной алфавит, {X, Y, Z} -- выходной алфавит
image::moore.dot.svg[Автомат Мура]

== Автоматы в HDL

Автоматы Мили и Мура часто используются как шаблоны для проектирования поведения различных систем: у системы есть набор состояний и она может переходить из одного состояния в другое под определённым внешним воздействием.
В том числе, такой шаблон часто поддерживают различные инструменты разработки для различных языков описания аппаратуры.

* https://www.mathworks.com/help/hdlcoder/ug/using-mealy-and-moore-machine-types-in-hdl-code-generation.html[Генерация HDL по диаграмме автомата в MATLAB].
* https://docs.amd.com/v/u/2018.3-English/ug901-vivado-synthesis[Принципы дизайна автоматов в официальном руководстве Xilinx/AMD].
* https://github.com/mohamed/fsm2sv/tree/main[Простой генератор автоматов Мили и Мура в SystemVerilog по их описанию].


IMPORTANT: Обязательно порешайте xref:exercises.adoc[упражнения].
