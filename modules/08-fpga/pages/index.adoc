= 8. Работа с ПЛИС

Наш курс в основном сосредоточен на написании собственной логики на языках описания аппаратуры и последующего её тестирования (верификации), поэтому до этого мы учились пользоваться именно симулятором, а не работали с реальной ПЛИС.
Тем не менее знания по работе с ПЛИС тоже важны, так что в этой части мы расскажем о работе с ПЛИС.

Сразу скажем, что современные ПЛИС достаточно сложные устройства и про их внутреннее устройство можно узнать в https://youtu.be/fdJiGdp5eVc?si=DWFrD_SNPEB_FQ1Q[лекции Школы синтеза цифровых схем].

== Процесс генерации прошивки

К сожалению, для генерации прошивки необходимо использовать проприетарные САПР от производителей ПЛИС, поэтому процесс работы для разных ПЛИС отличается{empty}footnote:[Попытки сделать open-source решения существуют, но часто требуют реверс-инженеринга: https://github.com/YosysHQ/nextpnr], но общий процесс един для всех.

Первый шаг -- синтез (synthesis) высокоуровневого кода на HDL в примитивы: LUT-ы, регистры, ALU, доступные на конкретной ПЛИС.
Следующий шаг -- раскладка (place and route) примитивов в ячейки конкретной ПЛИС.
Последний шаг -- генерация прошивки (bitstream).

Это крупные шаги, на самом деле каждый из них включает в себя более мелкие этапы, например анализ таймингов.

== Наши ПЛИС

В доступе у авторов курса имеются две ПЛИС: https://wiki.sipeed.com/hardware/en/tang/tang-primer-25k/primer-25k.html[Sipeed Tang Primer 25K] и https://wiki.sipeed.com/hardware/en/tang/tang-mega-138k/mega-138k-pro.html[Sipeed Tang Mega 138K Pro Dock].
Они используют чипы от компании Gowin, поэтому для дальнейшей работы предлагается xref:install-gowin.adoc[установить САПР Gowin].
Однако стандартное средство записи прошивок под Linux ведёт себя не очень хорошо, поэтому для прошивки будем использовать xref:install-openFPGAloader.adoc[openFPGAloader].

== Распознаватель числа, заданного кодом Хаффмана

Как и всегда будем строить наше повествование на примере.
Весь код можно найти в репозитории, мы же покажем только верхнеуровневый модуль, и другие важные для работы с ПЛИС файлы.
В качестве примера у нас будет распознаватель кода Хаффмана для чисел от 1 до 6, который будет подсвечивать светодиод с соответствующим номером, в соответствии с таблицей.

[%autowidth]
|===
| Число | Код Хаффмана

| 1 | 000
| 2 | 001
| 3 | 01
| 4 | 10
| 5 | 110
| 6 | 111
|===


[,verilog]
.src/08-fpga/huffman_top.sv
----
include::example$huffman_top.sv[]
----
<1> Объявляем наш верхнеуровневый модуль, именно к нему мы будем подключать все внешние сигналы.
<2> Обратите внимание, кнопки на наших ПЛИС -- нормально замкнутые, то есть в нажатом состоянии сигнал -- логический ноль.
<3> Светодиоды так же включаются на логический ноль.
<4> Первый модуль на пути сигнала -- подавитель дребезга.
Физические кнопки не идеальны и на самом деле генерируют падение и повышение сигнала с большой частотой при нажатии{empty}footnote:[https://nandland.com/debounce-a-switch/].
Поэтому для работы с сигналом дребезг нужно подавить.
<5> Следующий модуль заставляет систему регистрировать нажатие только один раз, вместо непрерывного сигнала.
<6> Конечный автомат превщающий код Хаффмана в число.
<7> Дешифратор для выбора светодиода.

== Работа с САПР

У нас есть код, теперь его нужно превратить в прошивку для ПЛИС.
Будем использовать Tang Primer 25K, аналогичные файлы для Mega 138K Pro Dock есть в репозитории.

NOTE: Все действия можно производить из графического интерфейса САПР, однако такой подход менее переносим, поэтому для управления САПР чаще всего будет применяться язык скриптовый язык Tcl{empty}footnote:[Внезапно статья на русской Википедии достаточно хороша: https://ru.wikipedia.org/wiki/Tcl].

Кроме кода нам нужно описать, как называются в нашем коде внешние сигналы, а также какую частоту управляющего сигнала мы хотим получить.
К сожалению, у каждого производителя свой формат описания.

Разберем формат описания сигналов на примере одного сигнала.
[, cst]
.src/08-fpga/primer25k_pin_constraints.cst
----
include::example$primer25k_pin_constraints.cst[lines=10..11]
----
<1> Директива `IO_LOC` указывает, что сигнал `led_o[5]` нужно подключить к пину B10;
<2> Директива `IO_PORT` указывает на настройки подключения, при написании вручную, можно опускать.

[TIP]
====
Для генерации файлов описания сигналов можно использовать инструмент Gowin FloorPlanner.
Он автоматически умеет генерировать директивы `IO_LOC` и `IO_PORT` с настройками по умолчанию здорово экономя время.
Побольше о нём можно найти в руководстве SUG935, которое находится в директории `$FPGA_TOOLS/docs/EN`.
====

[, sdc]
.src/08-fpga/timing_constraints.sdc
----
include::example$timing_constraints.sdc[lines=6]
----
<1> `create_clock` указывает на то, что хотим создать управляющий сигнал, `-name clk` указывает имя, `-period` указывает период в наносекундах, `[get_ports ++{++clk_i++}++]` указывает к какому порту подключается сигнал.

[TIP]
====
Для генерации файлов описания управляющих сигналов можно использовать Gowin Timing Constraint Editor.
Он обладает схожими с FloorPlanner удобствами.
Код руководства: SUG940.
====

Теперь мы можем создать проект.
Здесь будем предполагать, что мы находимся в директории `src/08-fpga`

WARNING: Мы показываем примеры для платы Primer 25k, поэтому они имеют префикс `primer25k`.
В случае если вы используете Mega 138k, то используйте файлы с префиксом `mega138k`.

Для генерации проекта запустим скрипт на языке Tcl из консольного обработчика команд САПР.
[,console]
----
$ gw_sh primer25k.tcl
----

После чего проект из директории можно будет открыть с помощью GUI интерфейса `gw_ide`.

Рассмотрим что же написано в скрипте `primer25k.tcl`.
[,tcl]
.src/08-fpga/primer25k.tcl
----
include::example$primer25k.tcl[]
----
<1> Создаем проект, указываем его название, модель ПЛИС, а так же указываем, что проект нужно создать, даже если такая директория уже существует.
Точки с запятой не обязательны, но необходимы для комментариев в конце строки.
<2> Указываем имя файла прошивки.
<3> Добавляем файл описания сигналов, так как он специфичен для конкретной модели ПЛИС.
Обратите внимание, здесь мы находимся уже в директории проекта, поэтому нам надо спуститься на уровень ниже.
<4> Вызываем другой файл с настройками для нескольких ПЛИС.

[,tcl]
.src/08-fpga/common.tcl
----
include::example$common.tcl[]
----
<1> Опишем только важные опции.
<2> Укажем, что управляющий сигнал не должен быть зарезервирован для некоего модуля CPU.
<3> Укажем верхнеуровневый модуль.
<4> Укажем версию Verilog, иначе наш код на SystemVerilog не синтезируется.
<5> Добавим файлы с кодом и с описанием управляющего сигнала.

NOTE: Подробнее об этих командах можно узнать в руководстве SUG100.

После открытия проекта `primer25k_huffman` в GUI, для генерации прошивки нужно нажать на зеленые стрелочки на панели инструментов и дождаться завершения процесса.

image::gw_ide.png[]

Теперь можно подключить ПЛИС.

.Для Primer 25k
[%collapsible]
====
image::primer25k.jpg[]
====

.Для Mega 138k
[%collapsible]
====
image::mega138k.jpg[]
====

Осталось прошить ПЛИС, для этого необходимо выполнить

[,console]
----
$ openFPGALoader primer25k_huffman/impl/pnr/primer25k_huffman.fs
----

Теперь можно пробовать вводить числа в коде Хаффмана.

IMPORTANT: Не забывайте про xref:exercises.adoc[упражнения].
